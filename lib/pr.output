state 114 contains 1 shift/reduce conflicts


-------- Grammar --------

rule 1 statements: statement
rule 2 statements: statements statement
rule 3 statement: EOS
rule 4 statement: COMMENT EOS
rule 5 statement: stmt EOS
rule 6 statement: stmt COMMENT EOS
rule 7 stmt: proccall
rule 8 stmt: call_stmt
rule 9 stmt: assign
rule 10 stmt: select_case
rule 11 stmt: case
rule 12 stmt: if
rule 13 stmt: elseif
rule 14 stmt: else
rule 15 stmt: for
rule 16 stmt: foreach
rule 17 stmt: do
rule 18 stmt: do_while
rule 19 stmt: do_until
rule 20 stmt: stmt_preamble
rule 21 stmt: END_IF
rule 22 stmt: NEXT
rule 23 stmt: LOOP
rule 24 stmt: EXIT_FOR
rule 25 stmt: EXIT_FOREACH
rule 26 stmt: EXIT_DO
rule 27 stmt: EXIT_SUB
rule 28 stmt: EXIT_FUNCTION
rule 29 stmt: END_SELECT
rule 30 stmt: END_SUB
rule 31 stmt: END_FUNCTION
rule 32 if: IF expr
rule 33 select_case: SELECT_CASE expr
rule 34 else: ELSE
rule 35 elseif: ELSEIF expr
rule 36 case: CASE expr
rule 37 case: CASE ELSE
rule 38 for: FOR VAR_NAME EQ expr TO expr
rule 39 foreach: FOREACH VAR_NAME IN var_ref
rule 40 do_while: DO WHILE expr
rule 41 do_until: DO UNTIL expr
rule 42 do: DO
rule 43 assign: assign_left EQ expr
rule 44 assign_left: var_or_func
rule 45 assign_left: assign_left COMMA var_or_func
rule 46 var_or_func: var_ref
rule 47 var_or_func: IDENT
rule 48 stmt_preamble: proc IDENT decl_args
rule 49 proc: SUB
rule 50 proc: FUNCTION
rule 51 value: LBRACE expr RBRACE
rule 52 value: STRING
rule 53 value: DIGITS
rule 54 value: var_ref
rule 55 value: TRUE
rule 56 value: FALSE
rule 57 value: NIL
rule 58 var_ref: VAR_NAME
rule 59 var_ref: VAR_NAME LBRACE arglist RBRACE
rule 60 proccall: IDENT call_args
rule 61 call_stmt: CALL IDENT call_args
rule 62 funcall: IDENT decl_args
rule 63 decl_args: 
rule 64 decl_args: LBRACE arglist RBRACE
rule 65 call_args: arglist
rule 66 call_args: LBRACE arglist RBRACE
rule 67 arglist: 
rule 68 arglist: arglist_m
rule 69 arglist_m: expr
rule 70 arglist_m: arglist_m COMMA expr
rule 71 expr: funcall
rule 72 expr: unary
rule 73 expr: binary
rule 74 expr: value
rule 75 unary: NOT expr
rule 76 unary: SUB expr
rule 77 binary: expr ADD expr
rule 78 binary: expr SUB expr
rule 79 binary: expr MUL expr
rule 80 binary: expr DIV expr
rule 81 binary: expr MOD expr
rule 82 binary: expr CAT expr
rule 83 binary: expr AND expr
rule 84 binary: expr OR expr
rule 85 binary: expr XOR expr
rule 86 binary: expr EQ expr
rule 87 binary: expr NE expr
rule 88 binary: expr LT expr
rule 89 binary: expr GT expr
rule 90 binary: expr LE expr
rule 91 binary: expr GE expr

------- Symbols -------

**Nonterminals, with rules where they appear

  $start (57)
    on right: 
    on left : 
  statements (58)
    on right: 2
    on left : 1 2
  statement (59)
    on right: 1 2
    on left : 3 4 5 6
  stmt (60)
    on right: 5 6
    on left : 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
  proccall (61)
    on right: 7
    on left : 60
  call_stmt (62)
    on right: 8
    on left : 61
  assign (63)
    on right: 9
    on left : 43
  select_case (64)
    on right: 10
    on left : 33
  case (65)
    on right: 11
    on left : 36 37
  if (66)
    on right: 12
    on left : 32
  elseif (67)
    on right: 13
    on left : 35
  else (68)
    on right: 14
    on left : 34
  for (69)
    on right: 15
    on left : 38
  foreach (70)
    on right: 16
    on left : 39
  do (71)
    on right: 17
    on left : 42
  do_while (72)
    on right: 18
    on left : 40
  do_until (73)
    on right: 19
    on left : 41
  stmt_preamble (74)
    on right: 20
    on left : 48
  expr (75)
    on right: 32 33 35 36 38 40 41 43 51 69 70 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
    on left : 71 72 73 74
  var_ref (76)
    on right: 39 46 54
    on left : 58 59
  assign_left (77)
    on right: 43 45
    on left : 44 45
  var_or_func (78)
    on right: 44 45
    on left : 46 47
  proc (79)
    on right: 48
    on left : 49 50
  decl_args (80)
    on right: 48 62
    on left : 63 64
  value (81)
    on right: 74
    on left : 51 52 53 54 55 56 57
  arglist (82)
    on right: 59 64 65 66
    on left : 67 68
  call_args (83)
    on right: 60 61
    on left : 65 66
  funcall (84)
    on right: 71
    on left : 62
  arglist_m (85)
    on right: 68 70
    on left : 69 70
  unary (86)
    on right: 72
    on left : 75 76
  binary (87)
    on right: 73
    on left : 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91

**Terminals, with rules where they appear

  $end (0) 
  error (1) 
  FUNCALL (2) 
  NEG (3) 
  NOT (4) 75
  MUL (5) 79
  DIV (6) 80
  MOD (7) 81
  ADD (8) 77
  SUB (9) 49 76 78
  CAT (10) 82
  LT (11) 88
  GT (12) 89
  LE (13) 90
  GE (14) 91
  EQ (15) 38 43 86
  NE (16) 87
  XOR (17) 85
  AND (18) 83
  OR (19) 84
  COMMA (20) 45 70
  EOS (21) 3 4 5 6
  COMMENT (22) 4 6
  END_IF (23) 21
  NEXT (24) 22
  LOOP (25) 23
  EXIT_FOR (26) 24
  EXIT_FOREACH (27) 25
  EXIT_DO (28) 26
  EXIT_SUB (29) 27
  EXIT_FUNCTION (30) 28
  END_SELECT (31) 29
  END_SUB (32) 30
  END_FUNCTION (33) 31
  IF (34) 32
  SELECT_CASE (35) 33
  ELSE (36) 34 37
  ELSEIF (37) 35
  CASE (38) 36 37
  FOR (39) 38
  VAR_NAME (40) 38 39 58 59
  TO (41) 38
  FOREACH (42) 39
  IN (43) 39
  DO (44) 40 41 42
  WHILE (45) 40
  UNTIL (46) 41
  IDENT (47) 47 48 60 61 62
  FUNCTION (48) 50
  LBRACE (49) 51 59 64 66
  RBRACE (50) 51 59 64 66
  STRING (51) 52
  DIGITS (52) 53
  TRUE (53) 55
  FALSE (54) 56
  NIL (55) 57
  CALL (56) 61

--------- State ---------

state 0


  SUB           shift, and go to state 40
  EOS           shift, and go to state 47
  COMMENT       shift, and go to state 5
  END_IF        shift, and go to state 9
  NEXT          shift, and go to state 13
  LOOP          shift, and go to state 17
  EXIT_FOR      shift, and go to state 22
  EXIT_FOREACH  shift, and go to state 26
  EXIT_DO       shift, and go to state 30
  EXIT_SUB      shift, and go to state 34
  EXIT_FUNCTION  shift, and go to state 37
  END_SELECT    shift, and go to state 42
  END_SUB       shift, and go to state 45
  END_FUNCTION  shift, and go to state 3
  IF            shift, and go to state 8
  SELECT_CASE   shift, and go to state 12
  ELSE          shift, and go to state 16
  ELSEIF        shift, and go to state 21
  CASE          shift, and go to state 25
  FOR           shift, and go to state 29
  VAR_NAME      shift, and go to state 33
  FOREACH       shift, and go to state 41
  DO            shift, and go to state 2
  IDENT         shift, and go to state 15
  FUNCTION      shift, and go to state 20
  CALL          shift, and go to state 6

  if            go to state 4
  assign_left   go to state 1
  elseif        go to state 10
  var_or_func   go to state 7
  else          go to state 14
  proc          go to state 11
  statements    go to state 19
  for           go to state 18
  statement     go to state 24
  foreach       go to state 23
  stmt          go to state 28
  do            go to state 27
  proccall      go to state 32
  do_while      go to state 31
  call_stmt     go to state 36
  do_until      go to state 35
  assign        go to state 39
  stmt_preamble  go to state 38
  select_case   go to state 43
  case          go to state 46
  var_ref       go to state 44

state 1

  43) assign : assign_left _ EQ expr
  45) assign_left : assign_left _ COMMA var_or_func

  EQ            shift, and go to state 48
  COMMA         shift, and go to state 49


state 2

  40) do_while : DO _ WHILE expr
  41) do_until : DO _ UNTIL expr
  42) do : DO _

  WHILE         shift, and go to state 50
  UNTIL         shift, and go to state 51
  $default      reduce using rule 42 (do)


state 3

  31) stmt : END_FUNCTION _

  $default      reduce using rule 31 (stmt)


state 4

  12) stmt : if _

  $default      reduce using rule 12 (stmt)


state 5

   4) statement : COMMENT _ EOS

  EOS           shift, and go to state 52


state 6

  61) call_stmt : CALL _ IDENT call_args

  IDENT         shift, and go to state 53


state 7

  44) assign_left : var_or_func _

  $default      reduce using rule 44 (assign_left)


state 8

  32) if : IF _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 65
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 9

  21) stmt : END_IF _

  $default      reduce using rule 21 (stmt)


state 10

  13) stmt : elseif _

  $default      reduce using rule 13 (stmt)


state 11

  48) stmt_preamble : proc _ IDENT decl_args

  IDENT         shift, and go to state 69


state 12

  33) select_case : SELECT_CASE _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 70
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 13

  22) stmt : NEXT _

  $default      reduce using rule 22 (stmt)


state 14

  14) stmt : else _

  $default      reduce using rule 14 (stmt)


state 15

  47) var_or_func : IDENT _
  60) proccall : IDENT _ call_args

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 72
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54
  EOS           reduce using rule 67 (arglist)
  COMMENT       reduce using rule 67 (arglist)
  $default      reduce using rule 47 (var_or_func)

  value         go to state 57
  arglist       go to state 71
  call_args     go to state 73
  funcall       go to state 59
  arglist_m     go to state 74
  expr          go to state 75
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 16

  34) else : ELSE _

  $default      reduce using rule 34 (else)


state 17

  23) stmt : LOOP _

  $default      reduce using rule 23 (stmt)


state 18

  15) stmt : for _

  $default      reduce using rule 15 (stmt)


state 19

   2) statements : statements _ statement

  $end          shift, and go to state 76
  SUB           shift, and go to state 40
  EOS           shift, and go to state 47
  COMMENT       shift, and go to state 5
  END_IF        shift, and go to state 9
  NEXT          shift, and go to state 13
  LOOP          shift, and go to state 17
  EXIT_FOR      shift, and go to state 22
  EXIT_FOREACH  shift, and go to state 26
  EXIT_DO       shift, and go to state 30
  EXIT_SUB      shift, and go to state 34
  EXIT_FUNCTION  shift, and go to state 37
  END_SELECT    shift, and go to state 42
  END_SUB       shift, and go to state 45
  END_FUNCTION  shift, and go to state 3
  IF            shift, and go to state 8
  SELECT_CASE   shift, and go to state 12
  ELSE          shift, and go to state 16
  ELSEIF        shift, and go to state 21
  CASE          shift, and go to state 25
  FOR           shift, and go to state 29
  VAR_NAME      shift, and go to state 33
  FOREACH       shift, and go to state 41
  DO            shift, and go to state 2
  IDENT         shift, and go to state 15
  FUNCTION      shift, and go to state 20
  CALL          shift, and go to state 6

  if            go to state 4
  assign_left   go to state 1
  elseif        go to state 10
  var_or_func   go to state 7
  else          go to state 14
  proc          go to state 11
  for           go to state 18
  statement     go to state 77
  foreach       go to state 23
  stmt          go to state 28
  do            go to state 27
  proccall      go to state 32
  do_while      go to state 31
  call_stmt     go to state 36
  do_until      go to state 35
  assign        go to state 39
  stmt_preamble  go to state 38
  select_case   go to state 43
  case          go to state 46
  var_ref       go to state 44

state 20

  50) proc : FUNCTION _

  $default      reduce using rule 50 (proc)


state 21

  35) elseif : ELSEIF _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 78
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 22

  24) stmt : EXIT_FOR _

  $default      reduce using rule 24 (stmt)


state 23

  16) stmt : foreach _

  $default      reduce using rule 16 (stmt)


state 24

   1) statements : statement _

  $default      reduce using rule 1 (statements)


state 25

  36) case : CASE _ expr
  37) case : CASE _ ELSE

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  ELSE          shift, and go to state 79
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 80
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 26

  25) stmt : EXIT_FOREACH _

  $default      reduce using rule 25 (stmt)


state 27

  17) stmt : do _

  $default      reduce using rule 17 (stmt)


state 28

   5) statement : stmt _ EOS
   6) statement : stmt _ COMMENT EOS

  EOS           shift, and go to state 82
  COMMENT       shift, and go to state 81


state 29

  38) for : FOR _ VAR_NAME EQ expr TO expr

  VAR_NAME      shift, and go to state 83


state 30

  26) stmt : EXIT_DO _

  $default      reduce using rule 26 (stmt)


state 31

  18) stmt : do_while _

  $default      reduce using rule 18 (stmt)


state 32

   7) stmt : proccall _

  $default      reduce using rule 7 (stmt)


state 33

  58) var_ref : VAR_NAME _
  59) var_ref : VAR_NAME _ LBRACE arglist RBRACE

  LBRACE        shift, and go to state 84
  $default      reduce using rule 58 (var_ref)


state 34

  27) stmt : EXIT_SUB _

  $default      reduce using rule 27 (stmt)


state 35

  19) stmt : do_until _

  $default      reduce using rule 19 (stmt)


state 36

   8) stmt : call_stmt _

  $default      reduce using rule 8 (stmt)


state 37

  28) stmt : EXIT_FUNCTION _

  $default      reduce using rule 28 (stmt)


state 38

  20) stmt : stmt_preamble _

  $default      reduce using rule 20 (stmt)


state 39

   9) stmt : assign _

  $default      reduce using rule 9 (stmt)


state 40

  49) proc : SUB _

  $default      reduce using rule 49 (proc)


state 41

  39) foreach : FOREACH _ VAR_NAME IN var_ref

  VAR_NAME      shift, and go to state 85


state 42

  29) stmt : END_SELECT _

  $default      reduce using rule 29 (stmt)


state 43

  10) stmt : select_case _

  $default      reduce using rule 10 (stmt)


state 44

  46) var_or_func : var_ref _

  $default      reduce using rule 46 (var_or_func)


state 45

  30) stmt : END_SUB _

  $default      reduce using rule 30 (stmt)


state 46

  11) stmt : case _

  $default      reduce using rule 11 (stmt)


state 47

   3) statement : EOS _

  $default      reduce using rule 3 (statement)


state 48

  43) assign : assign_left EQ _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 86
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 49

  45) assign_left : assign_left COMMA _ var_or_func

  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 88

  var_or_func   go to state 87
  var_ref       go to state 44

state 50

  40) do_while : DO WHILE _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 89
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 51

  41) do_until : DO UNTIL _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 90
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 52

   4) statement : COMMENT EOS _

  $default      reduce using rule 4 (statement)


state 53

  61) call_stmt : CALL IDENT _ call_args

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 72
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54
  $default      reduce using rule 67 (arglist)

  value         go to state 57
  arglist       go to state 71
  call_args     go to state 91
  funcall       go to state 59
  arglist_m     go to state 74
  expr          go to state 75
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 54

  57) value : NIL _

  $default      reduce using rule 57 (value)


state 55

  62) funcall : IDENT _ decl_args

  LBRACE        shift, and go to state 93
  $default      reduce using rule 63 (decl_args)

  decl_args     go to state 92

state 56

  75) unary : NOT _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 94
  var_ref       go to state 68
  binary        go to state 66

state 57

  74) expr : value _

  $default      reduce using rule 74 (expr)


state 58

  51) value : LBRACE _ expr RBRACE

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 95
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 59

  71) expr : funcall _

  $default      reduce using rule 71 (expr)


state 60

  52) value : STRING _

  $default      reduce using rule 52 (value)


state 61

  53) value : DIGITS _

  $default      reduce using rule 53 (value)


state 62

  76) unary : SUB _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 96
  var_ref       go to state 68
  binary        go to state 66

state 63

  72) expr : unary _

  $default      reduce using rule 72 (expr)


state 64

  55) value : TRUE _

  $default      reduce using rule 55 (value)


state 65

  32) if : IF expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 32 (if)


state 66

  73) expr : binary _

  $default      reduce using rule 73 (expr)


state 67

  56) value : FALSE _

  $default      reduce using rule 56 (value)


state 68

  54) value : var_ref _

  $default      reduce using rule 54 (value)


state 69

  48) stmt_preamble : proc IDENT _ decl_args

  LBRACE        shift, and go to state 93
  $default      reduce using rule 63 (decl_args)

  decl_args     go to state 112

state 70

  33) select_case : SELECT_CASE expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 33 (select_case)


state 71

  65) call_args : arglist _

  $default      reduce using rule 65 (call_args)


state 72

  51) value : LBRACE _ expr RBRACE
  66) call_args : LBRACE _ arglist RBRACE

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54
  $default      reduce using rule 67 (arglist)

  value         go to state 57
  arglist       go to state 113
  funcall       go to state 59
  arglist_m     go to state 74
  expr          go to state 114
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 73

  60) proccall : IDENT call_args _

  $default      reduce using rule 60 (proccall)


state 74

  68) arglist : arglist_m _
  70) arglist_m : arglist_m _ COMMA expr

  COMMA         shift, and go to state 115
  $default      reduce using rule 68 (arglist)


state 75

  69) arglist_m : expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 69 (arglist_m)


state 76


  $end          shift, and go to state 116


state 77

   2) statements : statements statement _

  $default      reduce using rule 2 (statements)


state 78

  35) elseif : ELSEIF expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 35 (elseif)


state 79

  37) case : CASE ELSE _

  $default      reduce using rule 37 (case)


state 80

  36) case : CASE expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 36 (case)


state 81

   6) statement : stmt COMMENT _ EOS

  EOS           shift, and go to state 117


state 82

   5) statement : stmt EOS _

  $default      reduce using rule 5 (statement)


state 83

  38) for : FOR VAR_NAME _ EQ expr TO expr

  EQ            shift, and go to state 118


state 84

  59) var_ref : VAR_NAME LBRACE _ arglist RBRACE

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54
  $default      reduce using rule 67 (arglist)

  value         go to state 57
  arglist       go to state 119
  funcall       go to state 59
  arglist_m     go to state 74
  expr          go to state 75
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 85

  39) foreach : FOREACH VAR_NAME _ IN var_ref

  IN            shift, and go to state 120


state 86

  43) assign : assign_left EQ expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 43 (assign)


state 87

  45) assign_left : assign_left COMMA var_or_func _

  $default      reduce using rule 45 (assign_left)


state 88

  47) var_or_func : IDENT _

  $default      reduce using rule 47 (var_or_func)


state 89

  40) do_while : DO WHILE expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 40 (do_while)


state 90

  41) do_until : DO UNTIL expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 41 (do_until)


state 91

  61) call_stmt : CALL IDENT call_args _

  $default      reduce using rule 61 (call_stmt)


state 92

  62) funcall : IDENT decl_args _

  $default      reduce using rule 62 (funcall)


state 93

  64) decl_args : LBRACE _ arglist RBRACE

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54
  $default      reduce using rule 67 (arglist)

  value         go to state 57
  arglist       go to state 121
  funcall       go to state 59
  arglist_m     go to state 74
  expr          go to state 75
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 94

  75) unary : NOT expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  $default      reduce using rule 75 (unary)


state 95

  51) value : LBRACE expr _ RBRACE
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  RBRACE        shift, and go to state 122


state 96

  76) unary : SUB expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  $default      reduce using rule 76 (unary)


state 97

  88) binary : expr LT _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 123
  var_ref       go to state 68
  binary        go to state 66

state 98

  89) binary : expr GT _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 124
  var_ref       go to state 68
  binary        go to state 66

state 99

  90) binary : expr LE _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 125
  var_ref       go to state 68
  binary        go to state 66

state 100

  91) binary : expr GE _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 126
  var_ref       go to state 68
  binary        go to state 66

state 101

  86) binary : expr EQ _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 127
  var_ref       go to state 68
  binary        go to state 66

state 102

  87) binary : expr NE _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 128
  var_ref       go to state 68
  binary        go to state 66

state 103

  79) binary : expr MUL _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 129
  var_ref       go to state 68
  binary        go to state 66

state 104

  85) binary : expr XOR _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 130
  var_ref       go to state 68
  binary        go to state 66

state 105

  80) binary : expr DIV _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 131
  var_ref       go to state 68
  binary        go to state 66

state 106

  83) binary : expr AND _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 132
  var_ref       go to state 68
  binary        go to state 66

state 107

  81) binary : expr MOD _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 133
  var_ref       go to state 68
  binary        go to state 66

state 108

  84) binary : expr OR _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 134
  var_ref       go to state 68
  binary        go to state 66

state 109

  77) binary : expr ADD _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 135
  var_ref       go to state 68
  binary        go to state 66

state 110

  78) binary : expr SUB _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 136
  var_ref       go to state 68
  binary        go to state 66

state 111

  82) binary : expr CAT _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  unary         go to state 63
  expr          go to state 137
  var_ref       go to state 68
  binary        go to state 66

state 112

  48) stmt_preamble : proc IDENT decl_args _

  $default      reduce using rule 48 (stmt_preamble)


state 113

  66) call_args : LBRACE arglist _ RBRACE

  RBRACE        shift, and go to state 138


state 114

  51) value : LBRACE expr _ RBRACE
  69) arglist_m : expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  RBRACE        shift, and go to state 122
  RBRACE        [reduce using rule 69 (arglist_m)]
  $default      reduce using rule 69 (arglist_m)


state 115

  70) arglist_m : arglist_m COMMA _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 139
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 116


  $default      accept


state 117

   6) statement : stmt COMMENT EOS _

  $default      reduce using rule 6 (statement)


state 118

  38) for : FOR VAR_NAME EQ _ expr TO expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 140
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 119

  59) var_ref : VAR_NAME LBRACE arglist _ RBRACE

  RBRACE        shift, and go to state 141


state 120

  39) foreach : FOREACH VAR_NAME IN _ var_ref

  VAR_NAME      shift, and go to state 33

  var_ref       go to state 142

state 121

  64) decl_args : LBRACE arglist _ RBRACE

  RBRACE        shift, and go to state 143


state 122

  51) value : LBRACE expr RBRACE _

  $default      reduce using rule 51 (value)


state 123

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  88) binary : expr LT expr _
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 88 (binary)


state 124

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  89) binary : expr GT expr _
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 89 (binary)


state 125

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  90) binary : expr LE expr _
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 90 (binary)


state 126

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr
  91) binary : expr GE expr _

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 91 (binary)


state 127

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  86) binary : expr EQ expr _
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            error
  NE            error
  $default      reduce using rule 86 (binary)


state 128

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  87) binary : expr NE expr _
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            error
  NE            error
  $default      reduce using rule 87 (binary)


state 129

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  79) binary : expr MUL expr _
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  $default      reduce using rule 79 (binary)


state 130

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  85) binary : expr XOR expr _
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  $default      reduce using rule 85 (binary)


state 131

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  80) binary : expr DIV expr _
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  $default      reduce using rule 80 (binary)


state 132

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  83) binary : expr AND expr _
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  $default      reduce using rule 83 (binary)


state 133

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  81) binary : expr MOD expr _
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  $default      reduce using rule 81 (binary)


state 134

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  84) binary : expr OR expr _
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  $default      reduce using rule 84 (binary)


state 135

  77) binary : expr _ ADD expr
  77) binary : expr ADD expr _
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  $default      reduce using rule 77 (binary)


state 136

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  78) binary : expr SUB expr _
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  $default      reduce using rule 78 (binary)


state 137

  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  82) binary : expr CAT expr _
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  $default      reduce using rule 82 (binary)


state 138

  66) call_args : LBRACE arglist RBRACE _

  $default      reduce using rule 66 (call_args)


state 139

  70) arglist_m : arglist_m COMMA expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 70 (arglist_m)


state 140

  38) for : FOR VAR_NAME EQ expr _ TO expr
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  TO            shift, and go to state 144


state 141

  59) var_ref : VAR_NAME LBRACE arglist RBRACE _

  $default      reduce using rule 59 (var_ref)


state 142

  39) foreach : FOREACH VAR_NAME IN var_ref _

  $default      reduce using rule 39 (foreach)


state 143

  64) decl_args : LBRACE arglist RBRACE _

  $default      reduce using rule 64 (decl_args)


state 144

  38) for : FOR VAR_NAME EQ expr TO _ expr

  NOT           shift, and go to state 56
  SUB           shift, and go to state 62
  VAR_NAME      shift, and go to state 33
  IDENT         shift, and go to state 55
  LBRACE        shift, and go to state 58
  STRING        shift, and go to state 60
  DIGITS        shift, and go to state 61
  TRUE          shift, and go to state 64
  FALSE         shift, and go to state 67
  NIL           shift, and go to state 54

  value         go to state 57
  funcall       go to state 59
  expr          go to state 145
  unary         go to state 63
  var_ref       go to state 68
  binary        go to state 66

state 145

  38) for : FOR VAR_NAME EQ expr TO expr _
  77) binary : expr _ ADD expr
  78) binary : expr _ SUB expr
  79) binary : expr _ MUL expr
  80) binary : expr _ DIV expr
  81) binary : expr _ MOD expr
  82) binary : expr _ CAT expr
  83) binary : expr _ AND expr
  84) binary : expr _ OR expr
  85) binary : expr _ XOR expr
  86) binary : expr _ EQ expr
  87) binary : expr _ NE expr
  88) binary : expr _ LT expr
  89) binary : expr _ GT expr
  90) binary : expr _ LE expr
  91) binary : expr _ GE expr

  MUL           shift, and go to state 103
  DIV           shift, and go to state 105
  MOD           shift, and go to state 107
  ADD           shift, and go to state 109
  SUB           shift, and go to state 110
  CAT           shift, and go to state 111
  LT            shift, and go to state 97
  GT            shift, and go to state 98
  LE            shift, and go to state 99
  GE            shift, and go to state 100
  EQ            shift, and go to state 101
  NE            shift, and go to state 102
  XOR           shift, and go to state 104
  AND           shift, and go to state 106
  OR            shift, and go to state 108
  $default      reduce using rule 38 (for)

