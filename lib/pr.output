state 0 contains 21 shift/reduce conflicts
state 0 contains 22 reduce/reduce conflicts
state 12 contains 1 shift/reduce conflicts
state 13 contains 2 shift/reduce conflicts
state 13 contains 1 reduce/reduce conflicts
state 29 contains 1 shift/reduce conflicts
state 32 contains 22 shift/reduce conflicts
state 32 contains 22 reduce/reduce conflicts
state 40 contains 18 shift/reduce conflicts
state 40 contains 22 reduce/reduce conflicts
state 48 contains 1 shift/reduce conflicts
state 50 contains 15 shift/reduce conflicts
state 57 contains 9 shift/reduce conflicts
state 62 contains 2 shift/reduce conflicts
state 95 contains 1 shift/reduce conflicts
state 98 contains 1 shift/reduce conflicts
state 109 contains 1 shift/reduce conflicts
state 110 contains 1 shift/reduce conflicts
state 111 contains 1 shift/reduce conflicts
state 112 contains 1 shift/reduce conflicts
state 113 contains 1 shift/reduce conflicts
state 114 contains 1 shift/reduce conflicts
state 115 contains 1 shift/reduce conflicts
state 116 contains 1 shift/reduce conflicts
state 117 contains 1 shift/reduce conflicts
state 118 contains 1 shift/reduce conflicts
state 119 contains 15 shift/reduce conflicts
state 120 contains 1 shift/reduce conflicts
state 121 contains 1 shift/reduce conflicts
state 122 contains 1 shift/reduce conflicts
state 123 contains 1 shift/reduce conflicts
state 124 contains 1 shift/reduce conflicts
state 130 contains 2 shift/reduce conflicts

rule 7 (statements) never reduced
rule 10 (stmt) never reduced

-------- Grammar --------

rule 1 top: 
rule 2 top: module_definition
rule 3 top: top module_definition
rule 4 module_definition: statements
rule 5 module_definition: stmt_preamble
rule 6 module_definition: end_something
rule 7 statements: 
rule 8 statements: stmt
rule 9 statements: statements stmt
rule 10 stmt: 
rule 11 stmt: proccall
rule 12 stmt: call_stmt
rule 13 stmt: assign
rule 14 stmt: select_case
rule 15 stmt: case
rule 16 stmt: if
rule 17 stmt: elseif
rule 18 stmt: else
rule 19 stmt: for
rule 20 stmt: END_IF
rule 21 stmt: NEXT
rule 22 stmt: do
rule 23 stmt: LOOP
rule 24 stmt: EXIT_FOR
rule 25 stmt: EXIT_DO
rule 26 stmt: EXIT_SUB
rule 27 stmt: EXIT_FUNCTION
rule 28 stmt: EXIT
rule 29 stmt: END_SELECT
rule 30 if: IF expr
rule 31 select_case: SELECT_CASE expr
rule 32 else: ELSE
rule 33 elseif: ELSE IF expr
rule 34 case: CASE expr
rule 35 case: CASE ELSE
rule 36 for: FOR assign TO expr step
rule 37 step: 
rule 38 step: step expr
rule 39 do: DO condition
rule 40 condition: 
rule 41 condition: edge expr
rule 42 edge: WHILE
rule 43 edge: UNTIL
rule 44 assign: assign_left EQ expr
rule 45 assign_left: var_or_func
rule 46 assign_left: assign_left COMMA var_or_func
rule 47 var_or_func: var_ref
rule 48 var_or_func: IDENT
rule 49 stmt_preamble: PROC IDENT decl_args
rule 50 end_something: END_SUB
rule 51 end_something: END_FUNCTION
rule 52 value: LBRACE expr RBRACE
rule 53 value: STRING
rule 54 value: DIGITS
rule 55 value: var_ref
rule 56 value: TRUE
rule 57 value: FALSE
rule 58 value: NIL
rule 59 var_ref: VAR_NAME var_args
rule 60 var_ref: VAR_NAME
rule 61 var_args: LBRACE arglist RBRACE
rule 62 proccall: IDENT call_args
rule 63 call_stmt: CALL IDENT call_args
rule 64 funcall: IDENT call_args
rule 65 decl_args: 
rule 66 decl_args: LBRACE arglist RBRACE
rule 67 call_args: arglist
rule 68 call_args: LBRACE arglist RBRACE
rule 69 arglist: 
rule 70 arglist: expr
rule 71 arglist: arglist COMMA expr
rule 72 expr: funcall
rule 73 expr: NOT expr
rule 74 expr: binary
rule 75 expr: value
rule 76 binary: expr EQ expr
rule 77 binary: expr NE expr
rule 78 binary: expr LT expr
rule 79 binary: expr GT expr
rule 80 binary: expr LE expr
rule 81 binary: expr GE expr
rule 82 binary: expr AND expr
rule 83 binary: expr OR expr
rule 84 binary: expr XOR expr
rule 85 binary: expr SCAT expr
rule 86 binary: expr PLUS expr
rule 87 binary: expr MINUS expr
rule 88 binary: expr ASTER expr
rule 89 binary: expr SLASH expr
rule 90 binary: expr MOD expr

------- Symbols -------

**Nonterminals, with rules where they appear

  $start (51)
    on right: 
    on left : 
  top (52)
    on right: 3
    on left : 1 2 3
  module_definition (53)
    on right: 2 3
    on left : 4 5 6
  statements (54)
    on right: 4 9
    on left : 7 8 9
  stmt_preamble (55)
    on right: 5
    on left : 49
  end_something (56)
    on right: 6
    on left : 50 51
  stmt (57)
    on right: 8 9
    on left : 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
  proccall (58)
    on right: 11
    on left : 62
  call_stmt (59)
    on right: 12
    on left : 63
  assign (60)
    on right: 13 36
    on left : 44
  select_case (61)
    on right: 14
    on left : 31
  case (62)
    on right: 15
    on left : 34 35
  if (63)
    on right: 16
    on left : 30
  elseif (64)
    on right: 17
    on left : 33
  else (65)
    on right: 18
    on left : 32
  for (66)
    on right: 19
    on left : 36
  do (67)
    on right: 22
    on left : 39
  expr (68)
    on right: 30 31 33 34 36 38 41 44 52 70 71 73 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90
    on left : 72 73 74 75
  step (69)
    on right: 36 38
    on left : 37 38
  condition (70)
    on right: 39
    on left : 40 41
  edge (71)
    on right: 41
    on left : 42 43
  assign_left (72)
    on right: 44 46
    on left : 45 46
  var_or_func (73)
    on right: 45 46
    on left : 47 48
  var_ref (74)
    on right: 47 55
    on left : 59 60
  decl_args (75)
    on right: 49
    on left : 65 66
  value (76)
    on right: 75
    on left : 52 53 54 55 56 57 58
  var_args (77)
    on right: 59
    on left : 61
  arglist (78)
    on right: 61 66 67 68 71
    on left : 69 70 71
  call_args (79)
    on right: 62 63 64
    on left : 67 68
  funcall (80)
    on right: 72
    on left : 64
  binary (81)
    on right: 74
    on left : 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90

**Terminals, with rules where they appear

  $end (0) 
  error (1) 
  FUNCALL (2) 
  NOT (3) 73
  ASTER (4) 88
  SLASH (5) 89
  MOD (6) 90
  PLUS (7) 86
  MINUS (8) 87
  LT (9) 78
  GT (10) 79
  LE (11) 80
  GE (12) 81
  EQ (13) 44 76
  NE (14) 77
  XOR (15) 84
  AND (16) 82
  OR (17) 83
  COMMA (18) 46 71
  END_IF (19) 20
  NEXT (20) 21
  LOOP (21) 23
  EXIT_FOR (22) 24
  EXIT_DO (23) 25
  EXIT_SUB (24) 26
  EXIT_FUNCTION (25) 27
  EXIT (26) 28
  END_SELECT (27) 29
  IF (28) 30 33
  SELECT_CASE (29) 31
  ELSE (30) 32 33 35
  CASE (31) 34 35
  FOR (32) 36
  TO (33) 36
  DO (34) 39
  WHILE (35) 42
  UNTIL (36) 43
  IDENT (37) 48 49 62 63 64
  PROC (38) 49
  END_SUB (39) 50
  END_FUNCTION (40) 51
  LBRACE (41) 52 61 66 68
  RBRACE (42) 52 61 66 68
  STRING (43) 53
  DIGITS (44) 54
  TRUE (45) 56
  FALSE (46) 57
  NIL (47) 58
  VAR_NAME (48) 59 60
  CALL (49) 63
  SCAT (50) 85

--------- State ---------

state 0


  END_IF        shift, and go to state 30
  END_IF        [reduce using rule 1 (top)]
  END_IF        [reduce using rule 7 (statements)]
  END_IF        [reduce using rule 10 (stmt)]
  NEXT          shift, and go to state 34
  NEXT          [reduce using rule 1 (top)]
  NEXT          [reduce using rule 7 (statements)]
  NEXT          [reduce using rule 10 (stmt)]
  LOOP          shift, and go to state 38
  LOOP          [reduce using rule 1 (top)]
  LOOP          [reduce using rule 7 (statements)]
  LOOP          [reduce using rule 10 (stmt)]
  EXIT_FOR      shift, and go to state 1
  EXIT_FOR      [reduce using rule 1 (top)]
  EXIT_FOR      [reduce using rule 7 (statements)]
  EXIT_FOR      [reduce using rule 10 (stmt)]
  EXIT_DO       shift, and go to state 5
  EXIT_DO       [reduce using rule 1 (top)]
  EXIT_DO       [reduce using rule 7 (statements)]
  EXIT_DO       [reduce using rule 10 (stmt)]
  EXIT_SUB      shift, and go to state 8
  EXIT_SUB      [reduce using rule 1 (top)]
  EXIT_SUB      [reduce using rule 7 (statements)]
  EXIT_SUB      [reduce using rule 10 (stmt)]
  EXIT_FUNCTION  shift, and go to state 10
  EXIT_FUNCTION  [reduce using rule 1 (top)]
  EXIT_FUNCTION  [reduce using rule 7 (statements)]
  EXIT_FUNCTION  [reduce using rule 10 (stmt)]
  EXIT          shift, and go to state 14
  EXIT          [reduce using rule 1 (top)]
  EXIT          [reduce using rule 7 (statements)]
  EXIT          [reduce using rule 10 (stmt)]
  END_SELECT    shift, and go to state 18
  END_SELECT    [reduce using rule 1 (top)]
  END_SELECT    [reduce using rule 7 (statements)]
  END_SELECT    [reduce using rule 10 (stmt)]
  IF            shift, and go to state 22
  IF            [reduce using rule 1 (top)]
  IF            [reduce using rule 7 (statements)]
  IF            [reduce using rule 10 (stmt)]
  SELECT_CASE   shift, and go to state 26
  SELECT_CASE   [reduce using rule 1 (top)]
  SELECT_CASE   [reduce using rule 7 (statements)]
  SELECT_CASE   [reduce using rule 10 (stmt)]
  ELSE          shift, and go to state 29
  ELSE          [reduce using rule 1 (top)]
  ELSE          [reduce using rule 7 (statements)]
  ELSE          [reduce using rule 10 (stmt)]
  CASE          shift, and go to state 33
  CASE          [reduce using rule 1 (top)]
  CASE          [reduce using rule 7 (statements)]
  CASE          [reduce using rule 10 (stmt)]
  FOR           shift, and go to state 37
  FOR           [reduce using rule 1 (top)]
  FOR           [reduce using rule 7 (statements)]
  FOR           [reduce using rule 10 (stmt)]
  DO            shift, and go to state 4
  DO            [reduce using rule 1 (top)]
  DO            [reduce using rule 7 (statements)]
  DO            [reduce using rule 10 (stmt)]
  IDENT         shift, and go to state 13
  IDENT         [reduce using rule 1 (top)]
  IDENT         [reduce using rule 7 (statements)]
  IDENT         [reduce using rule 10 (stmt)]
  PROC          shift, and go to state 17
  PROC          [reduce using rule 1 (top)]
  PROC          [reduce using rule 7 (statements)]
  PROC          [reduce using rule 10 (stmt)]
  END_SUB       shift, and go to state 20
  END_SUB       [reduce using rule 1 (top)]
  END_SUB       [reduce using rule 7 (statements)]
  END_SUB       [reduce using rule 10 (stmt)]
  END_FUNCTION  shift, and go to state 24
  END_FUNCTION  [reduce using rule 1 (top)]
  END_FUNCTION  [reduce using rule 7 (statements)]
  END_FUNCTION  [reduce using rule 10 (stmt)]
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 1 (top)]
  VAR_NAME      [reduce using rule 7 (statements)]
  VAR_NAME      [reduce using rule 10 (stmt)]
  CALL          shift, and go to state 16
  CALL          [reduce using rule 1 (top)]
  CALL          [reduce using rule 7 (statements)]
  CALL          [reduce using rule 10 (stmt)]
  $end          [reduce using rule 7 (statements)]
  $end          [reduce using rule 10 (stmt)]
  $default      reduce using rule 1 (top)

  stmt_preamble  go to state 3
  for           go to state 2
  end_something  go to state 7
  do            go to state 6
  stmt          go to state 9
  proccall      go to state 11
  call_stmt     go to state 15
  assign        go to state 19
  select_case   go to state 23
  assign_left   go to state 21
  case          go to state 27
  var_or_func   go to state 25
  top           go to state 32
  if            go to state 31
  var_ref       go to state 28
  module_definition  go to state 36
  elseif        go to state 35
  statements    go to state 40
  else          go to state 39

state 1

  24) stmt : EXIT_FOR _

  $default      reduce using rule 24 (stmt)


state 2

  19) stmt : for _

  $default      reduce using rule 19 (stmt)


state 3

   5) module_definition : stmt_preamble _

  $default      reduce using rule 5 (module_definition)


state 4

  39) do : DO _ condition

  WHILE         shift, and go to state 41
  UNTIL         shift, and go to state 42
  $default      reduce using rule 40 (condition)

  condition     go to state 43
  edge          go to state 44

state 5

  25) stmt : EXIT_DO _

  $default      reduce using rule 25 (stmt)


state 6

  22) stmt : do _

  $default      reduce using rule 22 (stmt)


state 7

   6) module_definition : end_something _

  $default      reduce using rule 6 (module_definition)


state 8

  26) stmt : EXIT_SUB _

  $default      reduce using rule 26 (stmt)


state 9

   8) statements : stmt _

  $default      reduce using rule 8 (statements)


state 10

  27) stmt : EXIT_FUNCTION _

  $default      reduce using rule 27 (stmt)


state 11

  11) stmt : proccall _

  $default      reduce using rule 11 (stmt)


state 12

  59) var_ref : VAR_NAME _ var_args
  60) var_ref : VAR_NAME _

  LBRACE        shift, and go to state 46
  LBRACE        [reduce using rule 60 (var_ref)]
  $default      reduce using rule 60 (var_ref)

  var_args      go to state 45

state 13

  48) var_or_func : IDENT _
  62) proccall : IDENT _ call_args

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  IDENT         [reduce using rule 69 (arglist)]
  LBRACE        shift, and go to state 59
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 69 (arglist)]
  EQ            reduce using rule 48 (var_or_func)
  COMMA         reduce using rule 48 (var_or_func)
  COMMA         [reduce using rule 69 (arglist)]
  $default      reduce using rule 69 (arglist)

  arglist       go to state 48
  call_args     go to state 51
  expr          go to state 50
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 14

  28) stmt : EXIT _

  $default      reduce using rule 28 (stmt)


state 15

  12) stmt : call_stmt _

  $default      reduce using rule 12 (stmt)


state 16

  63) call_stmt : CALL _ IDENT call_args

  IDENT         shift, and go to state 62


state 17

  49) stmt_preamble : PROC _ IDENT decl_args

  IDENT         shift, and go to state 63


state 18

  29) stmt : END_SELECT _

  $default      reduce using rule 29 (stmt)


state 19

  13) stmt : assign _

  $default      reduce using rule 13 (stmt)


state 20

  50) end_something : END_SUB _

  $default      reduce using rule 50 (end_something)


state 21

  44) assign : assign_left _ EQ expr
  46) assign_left : assign_left _ COMMA var_or_func

  EQ            shift, and go to state 64
  COMMA         shift, and go to state 65


state 22

  30) if : IF _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 66
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 23

  14) stmt : select_case _

  $default      reduce using rule 14 (stmt)


state 24

  51) end_something : END_FUNCTION _

  $default      reduce using rule 51 (end_something)


state 25

  45) assign_left : var_or_func _

  $default      reduce using rule 45 (assign_left)


state 26

  31) select_case : SELECT_CASE _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 68
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 27

  15) stmt : case _

  $default      reduce using rule 15 (stmt)


state 28

  47) var_or_func : var_ref _

  $default      reduce using rule 47 (var_or_func)


state 29

  32) else : ELSE _
  33) elseif : ELSE _ IF expr

  IF            shift, and go to state 69
  IF            [reduce using rule 32 (else)]
  $default      reduce using rule 32 (else)


state 30

  20) stmt : END_IF _

  $default      reduce using rule 20 (stmt)


state 31

  16) stmt : if _

  $default      reduce using rule 16 (stmt)


state 32

   3) top : top _ module_definition

  $end          shift, and go to state 70
  $end          [reduce using rule 7 (statements)]
  $end          [reduce using rule 10 (stmt)]
  END_IF        shift, and go to state 30
  END_IF        [reduce using rule 7 (statements)]
  END_IF        [reduce using rule 10 (stmt)]
  NEXT          shift, and go to state 34
  NEXT          [reduce using rule 7 (statements)]
  NEXT          [reduce using rule 10 (stmt)]
  LOOP          shift, and go to state 38
  LOOP          [reduce using rule 7 (statements)]
  LOOP          [reduce using rule 10 (stmt)]
  EXIT_FOR      shift, and go to state 1
  EXIT_FOR      [reduce using rule 7 (statements)]
  EXIT_FOR      [reduce using rule 10 (stmt)]
  EXIT_DO       shift, and go to state 5
  EXIT_DO       [reduce using rule 7 (statements)]
  EXIT_DO       [reduce using rule 10 (stmt)]
  EXIT_SUB      shift, and go to state 8
  EXIT_SUB      [reduce using rule 7 (statements)]
  EXIT_SUB      [reduce using rule 10 (stmt)]
  EXIT_FUNCTION  shift, and go to state 10
  EXIT_FUNCTION  [reduce using rule 7 (statements)]
  EXIT_FUNCTION  [reduce using rule 10 (stmt)]
  EXIT          shift, and go to state 14
  EXIT          [reduce using rule 7 (statements)]
  EXIT          [reduce using rule 10 (stmt)]
  END_SELECT    shift, and go to state 18
  END_SELECT    [reduce using rule 7 (statements)]
  END_SELECT    [reduce using rule 10 (stmt)]
  IF            shift, and go to state 22
  IF            [reduce using rule 7 (statements)]
  IF            [reduce using rule 10 (stmt)]
  SELECT_CASE   shift, and go to state 26
  SELECT_CASE   [reduce using rule 7 (statements)]
  SELECT_CASE   [reduce using rule 10 (stmt)]
  ELSE          shift, and go to state 29
  ELSE          [reduce using rule 7 (statements)]
  ELSE          [reduce using rule 10 (stmt)]
  CASE          shift, and go to state 33
  CASE          [reduce using rule 7 (statements)]
  CASE          [reduce using rule 10 (stmt)]
  FOR           shift, and go to state 37
  FOR           [reduce using rule 7 (statements)]
  FOR           [reduce using rule 10 (stmt)]
  DO            shift, and go to state 4
  DO            [reduce using rule 7 (statements)]
  DO            [reduce using rule 10 (stmt)]
  IDENT         shift, and go to state 13
  IDENT         [reduce using rule 7 (statements)]
  IDENT         [reduce using rule 10 (stmt)]
  PROC          shift, and go to state 17
  PROC          [reduce using rule 7 (statements)]
  PROC          [reduce using rule 10 (stmt)]
  END_SUB       shift, and go to state 20
  END_SUB       [reduce using rule 7 (statements)]
  END_SUB       [reduce using rule 10 (stmt)]
  END_FUNCTION  shift, and go to state 24
  END_FUNCTION  [reduce using rule 7 (statements)]
  END_FUNCTION  [reduce using rule 10 (stmt)]
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 7 (statements)]
  VAR_NAME      [reduce using rule 10 (stmt)]
  CALL          shift, and go to state 16
  CALL          [reduce using rule 7 (statements)]
  CALL          [reduce using rule 10 (stmt)]

  stmt_preamble  go to state 3
  for           go to state 2
  end_something  go to state 7
  do            go to state 6
  stmt          go to state 9
  proccall      go to state 11
  call_stmt     go to state 15
  assign        go to state 19
  select_case   go to state 23
  assign_left   go to state 21
  case          go to state 27
  var_or_func   go to state 25
  if            go to state 31
  var_ref       go to state 28
  module_definition  go to state 71
  elseif        go to state 35
  statements    go to state 40
  else          go to state 39

state 33

  34) case : CASE _ expr
  35) case : CASE _ ELSE

  NOT           shift, and go to state 53
  ELSE          shift, and go to state 73
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 72
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 34

  21) stmt : NEXT _

  $default      reduce using rule 21 (stmt)


state 35

  17) stmt : elseif _

  $default      reduce using rule 17 (stmt)


state 36

   2) top : module_definition _

  $default      reduce using rule 2 (top)


state 37

  36) for : FOR _ assign TO expr step

  IDENT         shift, and go to state 74
  VAR_NAME      shift, and go to state 12

  assign        go to state 75
  assign_left   go to state 21
  var_or_func   go to state 25
  var_ref       go to state 28

state 38

  23) stmt : LOOP _

  $default      reduce using rule 23 (stmt)


state 39

  18) stmt : else _

  $default      reduce using rule 18 (stmt)


state 40

   4) module_definition : statements _
   9) statements : statements _ stmt

  END_IF        shift, and go to state 30
  END_IF        [reduce using rule 4 (module_definition)]
  END_IF        [reduce using rule 10 (stmt)]
  NEXT          shift, and go to state 34
  NEXT          [reduce using rule 4 (module_definition)]
  NEXT          [reduce using rule 10 (stmt)]
  LOOP          shift, and go to state 38
  LOOP          [reduce using rule 4 (module_definition)]
  LOOP          [reduce using rule 10 (stmt)]
  EXIT_FOR      shift, and go to state 1
  EXIT_FOR      [reduce using rule 4 (module_definition)]
  EXIT_FOR      [reduce using rule 10 (stmt)]
  EXIT_DO       shift, and go to state 5
  EXIT_DO       [reduce using rule 4 (module_definition)]
  EXIT_DO       [reduce using rule 10 (stmt)]
  EXIT_SUB      shift, and go to state 8
  EXIT_SUB      [reduce using rule 4 (module_definition)]
  EXIT_SUB      [reduce using rule 10 (stmt)]
  EXIT_FUNCTION  shift, and go to state 10
  EXIT_FUNCTION  [reduce using rule 4 (module_definition)]
  EXIT_FUNCTION  [reduce using rule 10 (stmt)]
  EXIT          shift, and go to state 14
  EXIT          [reduce using rule 4 (module_definition)]
  EXIT          [reduce using rule 10 (stmt)]
  END_SELECT    shift, and go to state 18
  END_SELECT    [reduce using rule 4 (module_definition)]
  END_SELECT    [reduce using rule 10 (stmt)]
  IF            shift, and go to state 22
  IF            [reduce using rule 4 (module_definition)]
  IF            [reduce using rule 10 (stmt)]
  SELECT_CASE   shift, and go to state 26
  SELECT_CASE   [reduce using rule 4 (module_definition)]
  SELECT_CASE   [reduce using rule 10 (stmt)]
  ELSE          shift, and go to state 29
  ELSE          [reduce using rule 4 (module_definition)]
  ELSE          [reduce using rule 10 (stmt)]
  CASE          shift, and go to state 33
  CASE          [reduce using rule 4 (module_definition)]
  CASE          [reduce using rule 10 (stmt)]
  FOR           shift, and go to state 37
  FOR           [reduce using rule 4 (module_definition)]
  FOR           [reduce using rule 10 (stmt)]
  DO            shift, and go to state 4
  DO            [reduce using rule 4 (module_definition)]
  DO            [reduce using rule 10 (stmt)]
  IDENT         shift, and go to state 13
  IDENT         [reduce using rule 4 (module_definition)]
  IDENT         [reduce using rule 10 (stmt)]
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 4 (module_definition)]
  VAR_NAME      [reduce using rule 10 (stmt)]
  CALL          shift, and go to state 16
  CALL          [reduce using rule 4 (module_definition)]
  CALL          [reduce using rule 10 (stmt)]
  $end          [reduce using rule 10 (stmt)]
  PROC          [reduce using rule 10 (stmt)]
  END_SUB       [reduce using rule 10 (stmt)]
  END_FUNCTION  [reduce using rule 10 (stmt)]
  $default      reduce using rule 4 (module_definition)

  for           go to state 2
  do            go to state 6
  stmt          go to state 76
  proccall      go to state 11
  call_stmt     go to state 15
  assign        go to state 19
  select_case   go to state 23
  assign_left   go to state 21
  case          go to state 27
  var_or_func   go to state 25
  if            go to state 31
  var_ref       go to state 28
  elseif        go to state 35
  else          go to state 39

state 41

  42) edge : WHILE _

  $default      reduce using rule 42 (edge)


state 42

  43) edge : UNTIL _

  $default      reduce using rule 43 (edge)


state 43

  39) do : DO condition _

  $default      reduce using rule 39 (do)


state 44

  41) condition : edge _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 77
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 45

  59) var_ref : VAR_NAME var_args _

  $default      reduce using rule 59 (var_ref)


state 46

  61) var_args : LBRACE _ arglist RBRACE

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  $default      reduce using rule 69 (arglist)

  arglist       go to state 78
  expr          go to state 50
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 47

  54) value : DIGITS _

  $default      reduce using rule 54 (value)


state 48

  67) call_args : arglist _
  71) arglist : arglist _ COMMA expr

  COMMA         shift, and go to state 79
  COMMA         [reduce using rule 67 (call_args)]
  $default      reduce using rule 67 (call_args)


state 49

  56) value : TRUE _

  $default      reduce using rule 56 (value)


state 50

  70) arglist : expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  ASTER         [reduce using rule 70 (arglist)]
  SLASH         shift, and go to state 86
  SLASH         [reduce using rule 70 (arglist)]
  MOD           shift, and go to state 88
  MOD           [reduce using rule 70 (arglist)]
  PLUS          shift, and go to state 91
  PLUS          [reduce using rule 70 (arglist)]
  MINUS         shift, and go to state 92
  MINUS         [reduce using rule 70 (arglist)]
  LT            shift, and go to state 93
  LT            [reduce using rule 70 (arglist)]
  GT            shift, and go to state 94
  GT            [reduce using rule 70 (arglist)]
  LE            shift, and go to state 80
  LE            [reduce using rule 70 (arglist)]
  GE            shift, and go to state 81
  GE            [reduce using rule 70 (arglist)]
  EQ            shift, and go to state 82
  EQ            [reduce using rule 70 (arglist)]
  NE            shift, and go to state 83
  NE            [reduce using rule 70 (arglist)]
  XOR           shift, and go to state 85
  XOR           [reduce using rule 70 (arglist)]
  AND           shift, and go to state 87
  AND           [reduce using rule 70 (arglist)]
  OR            shift, and go to state 90
  OR            [reduce using rule 70 (arglist)]
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 70 (arglist)]
  $default      reduce using rule 70 (arglist)


state 51

  62) proccall : IDENT call_args _

  $default      reduce using rule 62 (proccall)


state 52

  57) value : FALSE _

  $default      reduce using rule 57 (value)


state 53

  73) expr : NOT _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 95
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 54

  72) expr : funcall _

  $default      reduce using rule 72 (expr)


state 55

  58) value : NIL _

  $default      reduce using rule 58 (value)


state 56

  74) expr : binary _

  $default      reduce using rule 74 (expr)


state 57

  64) funcall : IDENT _ call_args

  NOT           shift, and go to state 53
  NOT           [reduce using rule 69 (arglist)]
  IDENT         shift, and go to state 57
  IDENT         [reduce using rule 69 (arglist)]
  LBRACE        shift, and go to state 59
  LBRACE        [reduce using rule 69 (arglist)]
  STRING        shift, and go to state 61
  STRING        [reduce using rule 69 (arglist)]
  DIGITS        shift, and go to state 47
  DIGITS        [reduce using rule 69 (arglist)]
  TRUE          shift, and go to state 49
  TRUE          [reduce using rule 69 (arglist)]
  FALSE         shift, and go to state 52
  FALSE         [reduce using rule 69 (arglist)]
  NIL           shift, and go to state 55
  NIL           [reduce using rule 69 (arglist)]
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 69 (arglist)]
  $default      reduce using rule 69 (arglist)

  arglist       go to state 48
  call_args     go to state 96
  expr          go to state 50
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 58

  55) value : var_ref _

  $default      reduce using rule 55 (value)


state 59

  52) value : LBRACE _ expr RBRACE
  68) call_args : LBRACE _ arglist RBRACE

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  $default      reduce using rule 69 (arglist)

  arglist       go to state 97
  expr          go to state 98
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 60

  75) expr : value _

  $default      reduce using rule 75 (expr)


state 61

  53) value : STRING _

  $default      reduce using rule 53 (value)


state 62

  63) call_stmt : CALL IDENT _ call_args

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  IDENT         [reduce using rule 69 (arglist)]
  LBRACE        shift, and go to state 59
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 69 (arglist)]
  $default      reduce using rule 69 (arglist)

  arglist       go to state 48
  call_args     go to state 99
  expr          go to state 50
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 63

  49) stmt_preamble : PROC IDENT _ decl_args

  LBRACE        shift, and go to state 100
  $default      reduce using rule 65 (decl_args)

  decl_args     go to state 101

state 64

  44) assign : assign_left EQ _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 102
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 65

  46) assign_left : assign_left COMMA _ var_or_func

  IDENT         shift, and go to state 74
  VAR_NAME      shift, and go to state 12

  var_or_func   go to state 103
  var_ref       go to state 28

state 66

  30) if : IF expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 30 (if)


state 67

  52) value : LBRACE _ expr RBRACE

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 104
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 68

  31) select_case : SELECT_CASE expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 31 (select_case)


state 69

  33) elseif : ELSE IF _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 105
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 70


  $end          shift, and go to state 106


state 71

   3) top : top module_definition _

  $default      reduce using rule 3 (top)


state 72

  34) case : CASE expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 34 (case)


state 73

  35) case : CASE ELSE _

  $default      reduce using rule 35 (case)


state 74

  48) var_or_func : IDENT _

  $default      reduce using rule 48 (var_or_func)


state 75

  36) for : FOR assign _ TO expr step

  TO            shift, and go to state 107


state 76

   9) statements : statements stmt _

  $default      reduce using rule 9 (statements)


state 77

  41) condition : edge expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 41 (condition)


state 78

  61) var_args : LBRACE arglist _ RBRACE
  71) arglist : arglist _ COMMA expr

  COMMA         shift, and go to state 79
  RBRACE        shift, and go to state 108


state 79

  71) arglist : arglist COMMA _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 109
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 80

  80) binary : expr LE _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 110
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 81

  81) binary : expr GE _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 111
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 82

  76) binary : expr EQ _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 112
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 83

  77) binary : expr NE _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 113
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 84

  88) binary : expr ASTER _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 114
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 85

  84) binary : expr XOR _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 115
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 86

  89) binary : expr SLASH _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 116
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 87

  82) binary : expr AND _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 117
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 88

  90) binary : expr MOD _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 118
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 89

  85) binary : expr SCAT _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 119
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 90

  83) binary : expr OR _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 120
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 91

  86) binary : expr PLUS _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 121
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 92

  87) binary : expr MINUS _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 122
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 93

  78) binary : expr LT _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 123
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 94

  79) binary : expr GT _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 124
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 95

  73) expr : NOT expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 73 (expr)]
  $default      reduce using rule 73 (expr)


state 96

  64) funcall : IDENT call_args _

  $default      reduce using rule 64 (funcall)


state 97

  68) call_args : LBRACE arglist _ RBRACE
  71) arglist : arglist _ COMMA expr

  COMMA         shift, and go to state 79
  RBRACE        shift, and go to state 125


state 98

  52) value : LBRACE expr _ RBRACE
  70) arglist : expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  RBRACE        shift, and go to state 126
  RBRACE        [reduce using rule 70 (arglist)]
  SCAT          shift, and go to state 89
  $default      reduce using rule 70 (arglist)


state 99

  63) call_stmt : CALL IDENT call_args _

  $default      reduce using rule 63 (call_stmt)


state 100

  66) decl_args : LBRACE _ arglist RBRACE

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  $default      reduce using rule 69 (arglist)

  arglist       go to state 127
  expr          go to state 50
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 101

  49) stmt_preamble : PROC IDENT decl_args _

  $default      reduce using rule 49 (stmt_preamble)


state 102

  44) assign : assign_left EQ expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 44 (assign)


state 103

  46) assign_left : assign_left COMMA var_or_func _

  $default      reduce using rule 46 (assign_left)


state 104

  52) value : LBRACE expr _ RBRACE
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  RBRACE        shift, and go to state 126
  SCAT          shift, and go to state 89


state 105

  33) elseif : ELSE IF expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 33 (elseif)


state 106


  $default      accept


state 107

  36) for : FOR assign TO _ expr step

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12

  expr          go to state 128
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 108

  61) var_args : LBRACE arglist RBRACE _

  $default      reduce using rule 61 (var_args)


state 109

  71) arglist : arglist COMMA expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 71 (arglist)]
  $default      reduce using rule 71 (arglist)


state 110

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  80) binary : expr LE expr _
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 80 (binary)]
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 80 (binary)


state 111

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  81) binary : expr GE expr _
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 81 (binary)]
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 81 (binary)


state 112

  76) binary : expr _ EQ expr
  76) binary : expr EQ expr _
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 76 (binary)]
  EQ            error
  NE            error
  $default      reduce using rule 76 (binary)


state 113

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  77) binary : expr NE expr _
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 77 (binary)]
  EQ            error
  NE            error
  $default      reduce using rule 77 (binary)


state 114

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  88) binary : expr ASTER expr _
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 88 (binary)]
  $default      reduce using rule 88 (binary)


state 115

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  84) binary : expr XOR expr _
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 84 (binary)]
  $default      reduce using rule 84 (binary)


state 116

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  89) binary : expr SLASH expr _
  90) binary : expr _ MOD expr

  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 89 (binary)]
  $default      reduce using rule 89 (binary)


state 117

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  82) binary : expr AND expr _
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 82 (binary)]
  $default      reduce using rule 82 (binary)


state 118

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr
  90) binary : expr MOD expr _

  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 90 (binary)]
  $default      reduce using rule 90 (binary)


state 119

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  85) binary : expr SCAT expr _
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  ASTER         [reduce using rule 85 (binary)]
  SLASH         shift, and go to state 86
  SLASH         [reduce using rule 85 (binary)]
  MOD           shift, and go to state 88
  MOD           [reduce using rule 85 (binary)]
  PLUS          shift, and go to state 91
  PLUS          [reduce using rule 85 (binary)]
  MINUS         shift, and go to state 92
  MINUS         [reduce using rule 85 (binary)]
  LT            shift, and go to state 93
  LT            [reduce using rule 85 (binary)]
  GT            shift, and go to state 94
  GT            [reduce using rule 85 (binary)]
  LE            shift, and go to state 80
  LE            [reduce using rule 85 (binary)]
  GE            shift, and go to state 81
  GE            [reduce using rule 85 (binary)]
  EQ            shift, and go to state 82
  EQ            [reduce using rule 85 (binary)]
  NE            shift, and go to state 83
  NE            [reduce using rule 85 (binary)]
  XOR           shift, and go to state 85
  XOR           [reduce using rule 85 (binary)]
  AND           shift, and go to state 87
  AND           [reduce using rule 85 (binary)]
  OR            shift, and go to state 90
  OR            [reduce using rule 85 (binary)]
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 85 (binary)]
  $default      reduce using rule 85 (binary)


state 120

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  83) binary : expr OR expr _
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 83 (binary)]
  $default      reduce using rule 83 (binary)


state 121

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  86) binary : expr PLUS expr _
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 86 (binary)]
  $default      reduce using rule 86 (binary)


state 122

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  87) binary : expr MINUS expr _
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 87 (binary)]
  $default      reduce using rule 87 (binary)


state 123

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  78) binary : expr LT expr _
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 78 (binary)]
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 78 (binary)


state 124

  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  79) binary : expr GT expr _
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  SCAT          shift, and go to state 89
  SCAT          [reduce using rule 79 (binary)]
  LT            error
  GT            error
  LE            error
  GE            error
  $default      reduce using rule 79 (binary)


state 125

  68) call_args : LBRACE arglist RBRACE _

  $default      reduce using rule 68 (call_args)


state 126

  52) value : LBRACE expr RBRACE _

  $default      reduce using rule 52 (value)


state 127

  66) decl_args : LBRACE arglist _ RBRACE
  71) arglist : arglist _ COMMA expr

  COMMA         shift, and go to state 79
  RBRACE        shift, and go to state 129


state 128

  36) for : FOR assign TO expr _ step
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 37 (step)

  step          go to state 130

state 129

  66) decl_args : LBRACE arglist RBRACE _

  $default      reduce using rule 66 (decl_args)


state 130

  36) for : FOR assign TO expr step _
  38) step : step _ expr

  NOT           shift, and go to state 53
  IDENT         shift, and go to state 57
  IDENT         [reduce using rule 36 (for)]
  LBRACE        shift, and go to state 67
  STRING        shift, and go to state 61
  DIGITS        shift, and go to state 47
  TRUE          shift, and go to state 49
  FALSE         shift, and go to state 52
  NIL           shift, and go to state 55
  VAR_NAME      shift, and go to state 12
  VAR_NAME      [reduce using rule 36 (for)]
  $default      reduce using rule 36 (for)

  expr          go to state 131
  funcall       go to state 54
  binary        go to state 56
  var_ref       go to state 58
  value         go to state 60

state 131

  38) step : step expr _
  76) binary : expr _ EQ expr
  77) binary : expr _ NE expr
  78) binary : expr _ LT expr
  79) binary : expr _ GT expr
  80) binary : expr _ LE expr
  81) binary : expr _ GE expr
  82) binary : expr _ AND expr
  83) binary : expr _ OR expr
  84) binary : expr _ XOR expr
  85) binary : expr _ SCAT expr
  86) binary : expr _ PLUS expr
  87) binary : expr _ MINUS expr
  88) binary : expr _ ASTER expr
  89) binary : expr _ SLASH expr
  90) binary : expr _ MOD expr

  ASTER         shift, and go to state 84
  SLASH         shift, and go to state 86
  MOD           shift, and go to state 88
  PLUS          shift, and go to state 91
  MINUS         shift, and go to state 92
  LT            shift, and go to state 93
  GT            shift, and go to state 94
  LE            shift, and go to state 80
  GE            shift, and go to state 81
  EQ            shift, and go to state 82
  NE            shift, and go to state 83
  XOR           shift, and go to state 85
  AND           shift, and go to state 87
  OR            shift, and go to state 90
  SCAT          shift, and go to state 89
  $default      reduce using rule 38 (step)

